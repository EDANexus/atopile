##### typing of block objects, both classes and instances

block Component:
    str footprint = unknown
    node pin[str | int] = [any]

block NMOS:
    Signal gate
    Signal drain
    Signal source

block SomeNMOS from NMOS, Component:
    # only components can have footprints, pins
    gate.nominal_voltage = 0V to 10V
    gate ~ pin[1]
    drain ~ pin[2]
    source ~ pin[3]

block ParallelNMOS from NMOS:
    SomeNMOS n1, n2, n3  # ? on this syntax
    gate ~ n1.gate, n2.gate, n3.gate
    drain ~ n1.drain, n2.drain, n3.drain
    source ~ n1.source, n2.source, n3.source

block ThreeSomeNMOS from NMOS:
    # the one benifit to this syntax is that it allows you to create type unions
    # this means you're able to import from disperate sources and still use modules
    # BUT, we'd prefer to force you to wrap components in another block to commonise the interface
    NMOS n1, n2, n3
    gate ~ n1.gate, n2.gate, n3.gate
    drain ~ n1.drain, n2.drain, n3.drain
    source ~ n1.source, n2.source, n3.source

block HalfBridge:
    Signal vin
    Signal vout
    Signal gate
    Signal gnd

    NMOS high_fet
    NMOS low_fet

    vin ~ high_fet.drain
    vout ~ high_fet.source, low_fet.drain
    gate ~ high_fet.gate, low_fet.gate
    gnd ~ low_fet.source

block TopLevel:
    HalfBridge half_bridge
    # we need an operator which switches out a selected component to a specific type
    # the type must be a matching type to the original definition (eg. the same type or a sub-type)
    # in this case, we're swtiching out the FETs in the half-bridge with two different types of FET
    half_bridge.high_fet -> SomeNMOS
    half_bridge.low_fet -> ThreeSomeNMOS


##### typing of signals

node Signal:
    pass

node DigitalOutput from Signal:
    capacitance capacitance = unknown
    resistance on_stiffness = unknown
    resistance off_stiffness = unknown
    voltage on_voltage = unknown
    voltage off_voltage = unknown

node PushPullOutput from DigitalOutput:
    # we need a means to be able to define some kind of connected-compatabilities
    # eg. if you have a digital output, you can connect it to a digital input
    # but we should expect an error if you connect it to another DigitalOutput since they can both be driving
    PushPullOutput not in connections

    # TODO: consider the validity of this "not in" syntax

# What is the benefit of limiting the number of aspects GPIOs could be?
# I guess you can union those things and test against it?
union GPIO = (DigitalOutput | DigitalInput | AnalogOutput | AnalogInput)

block RP2040:
    GPIO gpio[:32]


##### maths; relationships and limits

# There's two obvious types of equations/relationships we can draw
# 1. limit which serve to bound the relationship between things
# 2. relations which describe the relationship between things

# to account for real-world fuzziness we also need the concept
# of tolerance/uncertainty which we will express using the first-class "ranges"
# I'm not entirely sure we need multiple constructs for this tbh...

# let's describe a simple voltage divider
block VDiv:
    PowerIn vin
    AnalogOutput vout
    Gnd gnd

    Resistor r1
    Resistor r2

    r1.pin[1] ~ vin
    r1.pin[2] ~ vout
    r2.pin[1] ~ vout
    r2.pin[2] ~ gnd

    # we can describe the relationship between the resistors
    float ratio == r1.value / r2.value
    vout.nominal_voltage == vin.nominal_voltage * ratio
    ohms total_resistance == r1.value + r2.value


# say we continue with this example of the half-bridge
block HalfBridge:
    PowerIn vin
    PowerOut vout
    DigitalInput gate
    Ground gnd

    NMOS high_fet
    NMOS low_fet

    current gate_current_target = 350mA to 400mA

    Resistor gate_resistor
    gate ~ gate_resistor.pin[1]
    gate_resistor.pin[2] ~ high_fet.gate, low_fet.gate
    gate.on_voltage > 6V  # all the gate.on_voltage range must be above 6V
    gate.off_voltage < 2V  # all the gate.off_voltage range must be below 2V
    # this equation must always be satified considering the ranges
    # TODO: the maths in this section deserves more specific attention
    gate_resistor.value == gate.on_voltage / gate_current_target - gate.on_stiffness

    vin ~ high_fet.drain
    vout ~ high_fet.source, low_fet.drain
    gnd ~ low_fet.source


##### repetition

# repeating yourself sucks, so we should have a means to define and connect things avoiding it
# let's look back at the ThreeSomeNMOS example if we adopt some functional programming concepts

# since the fet_count is fundemental to the definition of the block, it should be a parameter
block ParallelNMOS(int fet_count = 3) from NMOS:
    # this list, named "fet" of type NMOS contains a repeated element times "fet_count"
    NMOS fet[:fet_count]
    # when lists have their attributes accessed, they return a list of the same length
    # only attributes accessible from the contextually-known type are supported
    # eg. fet.gate is supported, fet.fet (in this case a recursive attribute) is not
    # connections can be made to the list, which will be applied to all elements as if it were written to each
    gate ~ fet.gate
    drain ~ fet.drain
    source ~ fet.source


##### selectors

# we can also imagine wanting to select a subset of a list
# note, this block has a int parameter
# undecided on this specific feature yet, but if we do roll with it,
# we should consider this something like a "preprocessor condition".
# That is, it's entirely evaluated and immutable at pre-compiling
block ResistorLadder(resistor_count):
    # just because the it's a preprocessor parameter, doesn't mean you can't apply
    # limits to it and do maths on it just like you would with other variables
    resistor_count >= 2

    Signal vin, gnd
    Signal vout[resistor_count-1]

    Resistor resistors[:resistor_count]

    resistors[0].pin[1] ~ vin
    # every second resistor, starting from the first connects to every second resistor starting from the second
    # lists of the same length connect each element to the corresponding when connected together
    resistors[::2].pin[1] ~ resistors[1::2].pin[2]
    resistors[-1].pin[2] ~ gnd

    resistors[:-2].pin[2] ~ vout

# we should also be able to select "all the elements of type ... in a context"
*Resistor  # all Resistors in the current context
**.*Resistor  # all Resistors in the current context and all child contexts
*.**.*Resistor  # all Resistors in all child contexts
*.*.*.*Resistor  # all Resistors in great-grandchild contexts

# another concept here would be to use something that's potentially more familiar; a builtin function. eg.:
all().all(Resistor)
# or, "any" being a keywork/builtin function that matches and depth of context as well (similar to "**")
any().all(Resistor)
# I'm still feeling this idea out, but since it reads literally, I kinda like it

any(Resistor).undefined().footprint = ...


block a:
    block b:
        test = unknown
        block c:
            test = 1

all(test) = 2

block a:
    block b:
        test = unknown
        block c:
            test = unknown

all(test) = 2
a.b.c.test = 1


# this is expected to be expecially useful in cases you're configuring something from a high-level, eg:
block ServoDrive from Module:
    HalfBridge a, b, c
    all(HalfBridge).all(NMOS) -> SomeNMOS

# the other powerful method we should consider is the ability to select a "fresh"
# "fresh" means the selector will only match things that haven't been previously selected
# I see some analogs here to the "next" builtin in python
# this is perhaps another case where the builtins/named functions compared to glob matching are more useful
# eg.:
block SomeBlock from Module:
    Resistor resistors[:3]
    Resistor res4

    # note we need to consider the validity of this = syntax,
    # since we're kinda just declaring a reference/pointer to the resource
    Resistor resistor_1 = resistors[1]  # select it explicitly
    Resistor resistor_0 = fresh(resistor)  # selects the next untouched resistor in the current context
    Resistor resistor_2 = fresh(Resistor)  # ^
    fresh(Resistor)  # throws a compiler error because there are no more resistors

block SomeMicro:
    I2C i2c1, i2c2

    i2c1.sda ~ pin[2]

SomeMicro some_micro
i2c_a = some_micro.fresh(I2C)

# in a lot of cases you just want "an" i2c bus from a micro, or "a" uart
# this fresh mechanism allows you to do that without having to explicitly naming them
# it also provides an imperative deconfliction method with other components that might be using the same resources


##### partials

# we can foreseeably want to define a block which is a partial of another block
# eg. if a package contains two op-amps and we want to use each of them on different circuits

block SomeDualOpAmp from Component:
    Signal vcc ~ pin[1]
    Signal gnd ~ pin[2]

    Opamp opamp[:2]

    opamp.vcc ~ vcc
    opamp.gnd ~ gnd

    # note, that if we want to connect these up properly to their
    #respective pins, we can simply do that outside the block in question
    opamp[0].in_pos ~ pin[3]
    opamp[0].out_pos ~ pin[4]
    # etc...

# this way we can trivially reference a "partial" section of a block, eg. one of the opamps
dual_op_amp = DualOpAmp
dual_op_amp.opamp[0]


class Test(super):
class Test:
    asdas


##### interfaces

node I2C:
    Signal sda
    Signal scl

node I2CMaster from I2C:
    pass

block SomeIC:
    I2C i2c1, i2c2

SomeIC some_ic
some_ic.i2c1 -> I2CMaster
some_ic.i2c1 ~ some_ic.i2c2


