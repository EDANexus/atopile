
# TYPES:
# There are 4 types:
# block, components, node and signal

# RULES:
# Blocks:
# A block class has a name
# A block instance has a name
# A block can contain a block
# A block can contain a component
# A block can contain a node
# A block can contain a signal
# A block instance can be replaced by another one assuming
# it's of the same class or a sub-class of that class
# A block can contain information about the component that it represents
# The variables "value" and "fields" are protected within a block

# Components:
# A component class has a name
# A component instance has a name
# A component follows all the rules stated above for a block and adds the following:
# the variables "footprint", "symbol" and "pin" are protected within a component.
# A component carries a pin list that can be associated to signals

# A node class has a name
# A node instance has a name
# A node can contain a node
# A node can contain a signal
# A node can connect to a node of the same class or a subclass of that class

# A signal class has a name
# A signal intance has a name
# A signal can contain electrical requirements
# A signal can connect to a signal

# CLASS DEFINITIONS:
# types can be defined like so:

block ABlock:
    pass

component AComponent:
    pass

node ANode:
    pass

signal ASignal:
    pass


# INSTANTIATION:
# Instantiation can be created like so:
a_block = new ABlock

a_component = new AComponent

a_node = new ANode

a_signal = new ASignal

# SUBCLASS:
# Sub classes can be created like so:
block BBlock from ABlock:
    pass

component BComponent from AComponent:
    pass
# Components can also inherit from blocks:
component CComponent from BBlock:
# However, the opposite is not true. Blocks can't inherit from components.

node BNode from ANode:
    pass

signal BSignal from ASignal:
    pass



# CLASS INSTANCE REPLACEMENT
# A block instance can be replaced by another block instance like so:
a_block -> BBlock
# In this case, the instance that exists within the variable a_block is replaced
# by a new instance of the class specified after the arrow "->"
# This operation is only allowed in cases where the replacement class if of the same
# type or from a subclass of the same class.



# COMPONENT SPECIFICATION

# Components classes can be defined like so:
# Start with a block
block Resistor:
    signal a
    signal b

# instantiate the block
res = new Resistor

# Import the block in the component
component VanillaResistor from Resistor:
    footprint = "0603"

# Apply the component to the block instance
res <- VanillaResistor

# A component can also be directly specified
component RP2040:
    footprint = "RP2040"
    signal vcc
    signal gnd



# SIGNAL TO PIN ASSOCIATION
# There are two ways to associate footprint pins to a block.
# The first one looks like so:

# We start by defining the aspects of our circuits while being agnostic of component selection
node Interface:
    signal anode
    signal cathode

block Diode:
    intf = new Interface

my_diode = new Diode

# We then select the actual component we want to use and create the pin to signal association
component DLLFSD01LPH47B from Diode:
    intf.anode ~ pin[1]
    intf.cathode ~ pin[2]["c"]
    # The "c" mention allows to further specifiy that the pin list element
    # 2 should be be replaced by the letter "c" when resolving the netlist.

# Fianlly, we apply the component information to the circuit
my_diode <- DLLFSD01LPH47B
# If we wanted to apply the same footprint to all diodes of that class, we could do so as well:
# Diode <- DLLFSD01LPH47B <- not sure we want to enable this. Using selectors might be cleaner.

# This first methode is useful to keep a circuit as agnostic as possible from final
# implementation.

# In the case where a very specific component and footprint have to be used, we can proceed like so:
component KDS114E:
    intf = new Interface
    footprint = "SOD123"
    intf.sig1 ~ pin[1]
    intf.sig1 ~ pin[2]["c"]


# VARIABLES
signal sda:
    capacitance capacitance = unknown
    resistance on_stiffness = unknown
    resistance off_stiffness = unknown
    voltage on_voltage = unknown
    voltage off_voltage = unknown


# REPETITION

block NMOS:
    signal gate
    signal drain
    signal source

block ParallelNMOS(int fet_count = 3) from NMOS:
    # this list, named "fet" of type NMOS contains a repeated element times "fet_count"
    fet[:fet_count] = new NMOS
    # when lists have their attributes accessed, they return a list of the same length
    # only attributes accessible from the contextually-known type are supported
    # eg. fet.gate is supported, fet.fet (in this case a recursive attribute) is not
    # connections can be made to the list, which will be applied to all elements as if it were written to each
    gate ~ fet.gate
    drain ~ fet.drain
    source ~ fet.source

# SELECTORS

block ResistorLadder(int resistor_count = 2):
    # just because the it's a preprocessor parameter, doesn't mean you can't apply
    # limits to it and do maths on it just like you would with other variables
    resistor_count >= 2

    signal vin
    signal gnd
    signal vout[resistor_count-1]

    resistors[:resistor_count] = new Resistor

    resistors[0].a ~ vin
    # every second resistor, starting from the first connects to every second resistor starting from the second
    # lists of the same length connect each element to the corresponding when connected together
    resistors[::2].a ~ resistors[1::2].b
    resistors[-1].b ~ gnd

    resistors[:-2].b ~ vout