
# TYPES:
# There are 4 types:
# block, components, node and signal

# RULES:
# Blocks:
# A block class has a name
# A block instance has a name
# A block can contain a block
# A block can contain a component
# A block can contain a node
# A block can contain a signal
# A block instance can be replaced by another one assuming
# it's of the same class or a sub-class of that class
# A block can contain information about the component that it represents
# The variables "value" and "fields" are protected within a block

# Components:
# A component class has a name
# A component instance has a name
# A component follows all the rules stated above for a block and adds the following:
# the variables "footprint", "symbol" and "pin" are protected within a component.
# A component carries a pin list that can be associated to signals

# A node class has a name
# A node instance has a name
# A node can contain a node
# A node can contain a signal
# A node can connect to a node of the same class or a subclass of that class

# A signal class has a name
# A signal intance has a name
# A signal can contain electrical requirements
# A signal can connect to a signal

# CLASS DEFINITIONS:
# types can be defined like so:

block ABlock:
    pass

component AComponent:
    pass

node ANode:
    pass

signal ASignal:
    pass


# INSTANTIATION:
# Instantiation can be created like so:
a_block = new ABlock

a_component = new AComponent

a_node = new ANode

a_signal = new ASignal

# SUBCLASS:
# Sub classes can be created like so:
block BBlock from ABlock:
    pass

component BComponent from AComponent:
    pass
# Components can also inherit from blocks:
component CComponent from BBlock:
# However, the opposite is not true. Blocks can't inherit from components.

node BNode from ANode:
    pass

signal BSignal from ASignal:
    pass



# CLASS INSTANCE REPLACEMENT
# A block instance can be replaced by another block instance like so:
a_block -> BBlock
# In this case, the instance that exists within the variable a_block is replaced
# by a new instance of the class specified after the arrow "->"
# This operation is only allowed in cases where the replacement class if of the same
# type or from a subclass of the same class.



# COMPONENT SPECIFICATION

# Components classes can be defined like so:
# Start with a block
block Resistor:
    signal a
    signal b

# instantiate the block
res = new Resistor

# Import the block in the component
component VanillaResistor from Resistor:
    footprint = "0603"

# Apply the component to the block instance
res <- VanillaResistor

# A component can also be directly specified
component RP2040:
    footprint = "RP2040"
    signal vcc
    signal gnd



# SIGNAL TO PIN ASSOCIATION
# There are two ways to associate footprint pins to a block.
# The first one looks like so:

# We start by defining the aspects of our circuits while being agnostic of component selection
node Interface:
    signal anode
    signal cathode

block Diode:
    intf = new Interface

my_diode = new Diode

# We then select the actual component we want to use and create the pin to signal association
component DLLFSD01LPH47B from Diode:
    intf.anode ~ pin[1]
    intf.cathode ~ pin[2]["c"]
    # The "c" mention allows to further specifiy that the pin list element
    # 2 should be be replaced by the letter "c" when resolving the netlist.

# Fianlly, we apply the component information to the circuit
my_diode <- DLLFSD01LPH47B
# If we wanted to apply the same footprint to all diodes of that class, we could do so as well:
# Diode <- DLLFSD01LPH47B <- not sure we want to enable this. Using selectors might be cleaner.

# This first methode is useful to keep a circuit as agnostic as possible from final
# implementation.

# In the case where a very specific component and footprint have to be used, we can proceed like so:
block KDS114E:
    intf = new Interface
    footprint = "SOD123"
    intf.sig1 ~ pin[1]
    intf.sig1 ~ pin[2]["c"]




