
# TYPES:
# There are 3 types:
# block, node and signal

# RULES:
# Blocks:
# A block class has a name
# A block instance has a name
# A block can contain a block
# A block can contain a component
# A block can contain a node
# A block can contain a signal
# A block instance can be replaced by another one assuming
# it's of the same class or a sub-class of that class
# A block can contain information about the component that it represents
# The variables "value", "fields", "footprint", "symbol" and "pin" are protected within a block
# The variables "footprint", "symbol" and "pin" are considered to be
# part of component information.

# Components:
# A component has a name
# A component instance does not have a name and can only exist within a block
# A component can carry information in fields
# A component carries a pin list by default
# The pin list can be connected to signals

# A node class has a name
# A node instance has a name
# A node can contain a node
# A node can contain a signal
# A node can connect to a node of the same class or a subclass of that class

# A signal class has a name
# A signal intance has a name
# A signal can contain electrical requirements
# A signal can connect to a signal

# CLASS DEFINITIONS:
# types can be defined like so:

block ABlock:
    pass

node ANode:
    pass

signal ASignal:
    pass

# INSTANTIATION:
# Instantiation can be created like so:
a_block = new ABlock

a_node = new ANode

a_signal = new ASignal

# SUBCLASS:
# Sub classes can be created like so:
block BBlock from ABlock:
    pass

node BNode from ANode:
    pass

signal BSignal from ASignal:
    pass

# CLASS INSTANCE REPLACEMENT
# A block instance can be replaced by another block instance like so:
a_block -> BBlock
# In this case, the instance that exists within the variable a_block is replaced
# by a new instance of the class specified after the arrow "->"
# This operation is only allowed in cases where the replacement class if of the same
# type or from a subclass of the same class.

# COMPONENT SPECIFICATION
block VanillaResistor:
    footprint = "0603"

block RandomClass:
    value = 1
# Component variables ("footprint", "symbol" and "pin") can be added to a block class like so:
a_block <- VanillaResistor
# A block can only contain information from a single component.
# If a further addition is made, it replaces the content of the previous one.
a_block <- RandomClass
# a_block now contain the RandomClass information

# SIGNAL TO PIN ASSOCIATION
# There are two ways to associate footprint pins to a block.
# The first one looks like so:

# We start by defining the aspects of our circuits while being agnostic of component selection
node Interface:
    signal anode
    signal cathode

block Diode:
    intf = new Interface

my_diode = new Diode

# We then select the actual component we want to use and create the pin to signal association
block DLLFSD01LPH47B from Diode:
    intf.anode ~ pin[1]
    intf.cathode ~ pin[2]["c"]
    # The "c" mention allows to further specifiy that the pin list element
    # 2 should be be replaced by the letter "c" when resolving the netlist.

# Fianlly, we apply the component information to the circuit
my_diode <- DLLFSD01LPH47B
# If we wanted to apply the same footprint to all diodes of that class, we could do so as well:
Diode <- DLLFSD01LPH47B

# This first methode is useful to keep a circuit as agnostic as possible from final
# implementation.

# In the case where a very specific component and footprint have to be used, we can proceed like so:
block KDS114E:
    intf = new Interface
    footprint = "SOD123"
    intf.sig1 ~ pin[1]
    intf.sig1 ~ pin[2]["c"]


